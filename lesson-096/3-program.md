# program: 遍历所有的三阶幻方

## 算法I(穷举法)

三阶幻方一共9个数: 1 ~ 9. 如下排列：

| 8 | 1 | 6 |
| 3 | 5 | 7 |
| 4 | 9 | 2 |

现在要求列出 1 ~ 9 所有的三阶幻方。

一种最简单的方法，就是对于九宫格中的每个数字都取 1 ~ 9 这九个数，然后挑选出满足下面两个条件的排列。

- 数字不重复
- 三行、三列、两条对角线上三个数之和相等

如此，得到如下的伪代码:

```python
def check_and_output(a1, a2, ..., a9):
    # check ...

    # output ...

    pass

for a1 in range(1, 10):
    for a2 in range(1, 10):
        ...
            for a9 in range(1, 10):
                check_and_output(a1, a2, ..., a9)
```

为了简化，现在将合法性检查和打印输出合并在一起。

注意，在编码以及调试过程中，我们尽量先保证每个模块(本例为函数)都正确，然后再将所有模块联合起来调试。具体到这里，我们可以先拿一个合法幻方的9个数字，去验证 ```check_and_output(...)``` 的功能是否正确；然后再和下面的多重for循环结合起来调试。

思考: 如果不先验证 ```check_and_output(...)```，可能会出现什么情况？

## 性能提升

通过运行上面的代码，会发现代码执行一遍需要很长时间。因此，需要思考如何提高代码的运行效率。

其中一种方法是，在多重循环时，及时增加判别。比如当遍历了九宫格的前三个数的时候，就可以及时检查这三个数作为九宫格的第一行，其三个数的和是否等于幻和；同样地，当遍历了接下来的第四、五、六三个数的时候，也检查其幻和。通过这种方法，可以极大的减少不必要的遍历。

伪代码:

```python
magic_sum = 15
for a1 in range(1, 10):
    for a2 in range(1, 10):
        for a3 in range(1, 10):
            if a1 + a2 + a3 != magic_sum:
                continue

            for a4 in range(1, 10):
                for a5 in range(1, 10):
                    for a6 in range(1, 10):
                        if a4 + a5 + a6 != magic_sum:
                            continue
                    ...
```

### magic sum

易知如下的幻和计算公式：

```
幻和 magic sum = sum(1~9) / 3
```

## 参考代码

- magic.py: 穷举法
- magic2.py: 穷举法+及早排除

# 性能对比

机器: i5 8G

- magic.py: 00:14:19
- magic2.py: 00:00:00
